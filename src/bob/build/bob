#!/usr/bin/env bash
set -euo pipefail
##########################################
# Helper functions to solve paths
# Globals:
#   None
# Arguments:
#   string path
# Returns:
#   string
##########################################
bashop::resolve_link() {
  $(type -p greadlink readlink | head -1) "${1}"
}
##########################################
# Return the absolute dir name
# Globals:
#   None
# Arguments:
#   string path
# Returns:
#   string
##########################################
bashop::abs_dirname() {
  local cwd="$(pwd)"
  local path="${1}"
  while [[ -n "${path}" ]]; do
    cd "${path%/*}"
    local name="${path##*/}"
    path="$(bashop::resolve_link "${name}" || true)"
  done
  pwd
  cd "${cwd}"
}
# Set needed paths
readonly BASHOP_ROOT="$(bashop::abs_dirname "${BASH_SOURCE[0]}")"
readonly BASHOP_APP_ROOT="$(bashop::abs_dirname "${0}")"
readonly BASHOP_APP_COMMAND_ROOT="${BASHOP_APP_ROOT}/commands"
# Set default options
readonly _BASHOP_BUILD_IN_OPTIONS=(
    "-h --help  Shows this help"
    "-v --verbose  Shows more detailed information"
)
# Include files
##############################
# Checks if a variable is set
# Globals:
#   None
# Arguments:
#   mixed variable
# Returns:
#   bool
##############################
bashop::utils::isset() {
  if [[ ${1+isset} == 'isset' ]]; then
    return 0
  fi
  return 1
}
###############################################
# Checks if a array contains the given element
# Globals:
#   None
# Arguments:
#   string needle
#   array  haystack
# Returns:
#   bool
###############################################
bashop::utils::contains_element() {
  local e
  for e in "${@:2}"; do
    [[ "${e}" == "${1}" ]] && return 0
  done
  return 1
}
#####################################################
# Checks if the given key exists for the given array
# Globals:
#   None
# Arguments:
#   string needle
#   array  haystack
# Returns:
#   bool
#####################################################
bashop::utils::key_exists() {
  eval '[ ${'${2}'[${1}]+key_exists} ]'
}
#######################################################
# Checks if the given string matches the option format
# Globals:
#   None
# Arguments:
#   string option
# Returns:
#   bool
#######################################################
bashop::utils::is_option() {
  if [[ ${1} =~ ^-{1,2}[^-].* ]]; then
    return 0
  fi
  return 1
}
######################################
# Checks if the given function exists
# Globals:
#   None
# Arguments:
#   string function_name
# Returns:
#   bool
######################################
bashop::utils::function_exists() {
  echo ${1}
  declare -f -F ${1} > /dev/null
  return $?
}
##################################
# Repeat the given string n times
# Globals:
#   None
# Arguments:
#   string string_to_repeat
#   int    repeat_times
# Returns:
#   string
##################################
bashop::utils::string_repeat() {
  if [[ ${2} -gt 0 ]]; then
    eval="echo {1.."$(($2))"}"
    printf "${1}%.0s" $(eval ${eval})
  fi
}
#################################################################
# Finds the min length of a collection of strings given by array
# Globals:
#   None
# Arguments:
#   array search
# Returns:
#   int
#################################################################
bashop::utils::min_string_length() {
  local search=("${!1}")
  echo $(bashop::utils::string_length search[@] "min")
}
#################################################################
# Finds the max length of a collection of strings given by array
# Globals:
#   None
# Arguments:
#   array search
# Returns:
#   int
#################################################################
bashop::utils::max_string_length() {
  local search=("${!1}")
  echo $(bashop::utils::string_length search[@] "max")
}
#############################################################
# Finds the length of a collection of strings given by array
# Globals:
#   None
# Arguments:
#   array  search
#   string type   Possible values are be min, max or diff
# Returns:
#   int
#############################################################
bashop::utils::string_length() {
  local strings=("${!1}")
  local min_length=false
  local max_length=0
  local string=()
  for string in "${strings[@]}"; do
    if [[ ${min_length} == false ]] || [[ ${#string} -lt ${min_length} ]]; then
      min_length=${#string}
    fi
    if [[ ${#string} -gt ${max_length} ]]; then
      max_length=${#string}
    fi
  done
  local type=${2}
  if [[ ${type} == 'min' ]]; then
    echo ${min_length}
  elif [[ ${type} == 'max' ]]; then
    echo ${max_length}
  elif [[ ${type} == 'diff' ]]; then
    echo $((max_length - min_length))
  fi
}
##########################################################
# Checks if the min version is lower than the cur version
# Globals:
#   None
# Arguments:
#   string min_version
#   string cur_version
# Returns:
#   bool
##########################################################
bashop::utils::check_version() {
  local min_version=${1}
  local mv=()
  local cur_version=${2}
  local cv=()
  local version_regex="^([0-9]+)\.([0-9]+)\.([0-9]+).*"
  if [[ ${min_version} =~ ${version_regex} ]]; then
    mv+=( ${BASH_REMATCH[1]} )
    mv+=( ${BASH_REMATCH[2]} )
    mv+=( ${BASH_REMATCH[3]} )
  else
    bashop::printer::error "Wrong version format for '${min_version}'."
    exit 1
  fi
  if [[ ${cur_version} =~ ${version_regex} ]]; then
    cv+=( ${BASH_REMATCH[1]} )
    cv+=( ${BASH_REMATCH[2]} )
    cv+=( ${BASH_REMATCH[3]} )
  else
    bashop::printer::error "Wrong version format for '${cur_version}'."
    exit 1
  fi
  if ( [[ ${mv[0]} -lt ${cv[0]} ]] ) ||
     ( [[ ${mv[0]} -le ${cv[0]} ]] && [[ ${mv[1]} -lt ${cv[1]} ]] ) ||
     ( [[ ${mv[0]} -le ${cv[0]} ]] && [[ ${mv[1]} -le ${cv[1]} ]] && [[ ${mv[2]} -lt ${cv[2]} ]] )
  then
    return 0
  fi
  return 1
}
##########################################
# Default output command of the framework
# Globals:
#   None
# Arguments:
#   string msg
#   string line_separator (optional)
# Returns:
#   string
##########################################
bashop::printer::echo() {
  printf '%s' "${1}"
  if ! [[ -n ${2+1} ]]; then
    printf "\n"
  elif [[ ${2} != false ]]; then
    printf "${2}"
  fi
}
######################
# Info output command
# Globals:
#   None
# Arguments:
#   string msg
#   string line_separator (optional)
# Returns:
#   string
######################
bashop::printer::info() {
  printf "\033[00;34m"
  bashop::printer::echo "Info: ${1}" "${@:2}"
  printf "\033[0m"
}
######################
# User output command
# Globals:
#   None
# Arguments:
#   string msg
#   string line_separator (optional)
# Returns:
#   string
######################
bashop::printer::user() {
  printf "\033[00;33m"
  bashop::printer::echo "${1}" "${@:2}"
  printf "\033[0m"
}
#########################
# Success output command
# Globals:
#   None
# Arguments:
#   string msg
#   string line_separator (optional)
# Returns:
#   string
#########################
bashop::printer::success() {
  printf "\033[00;32m"
  bashop::printer::echo "${1}" "${@:2}"
  printf "\033[0m"
}
########################################
# Error output command of the framework
# Globals:
#   None
# Arguments:
#   string msg
#   string line_separator (optional)
# Returns:
#   string
########################################
bashop::printer::error() {
  printf "\033[00;31m"
  bashop::printer::echo "Error: ${1}" "${@:2}"
  printf "\033[0m"
}
#########################
# Verbose output command
# Globals:
#   None
# Arguments:
#   string msg
#   string line_separator (optional)
# Returns:
#   string
#########################
bashop::printer::verbose() {
  if [[ -n ${_BASHOP_VERBOSE+1} ]] && [[ ${_BASHOP_VERBOSE} == true ]]; then
    printf "\033[00;34m"
    bashop::printer::echo "${1}" "${@:2}"
    printf "\033[0m"
  fi
}
#################################
# Framework error output command
# Globals:
#   None
# Arguments:
#   string msg
# Returns:
#   string
#################################
bashop::printer::__framework_error() {
  local msg=${1}
  local full_msg=''
  full_msg+="It's not your fault... expect you are the developer of this application or worse "
  full_msg+="you are the user and changed something, than congratulations you broke it ;). "
  full_msg+="If you are a user and you didn't done something then please send the developer "
  full_msg+="of this application the following message as error report:\n\nFRAMEWORK ERROR: ${msg}\n"
  printf "\033[00;31m"
  printf "${full_msg}"
  printf "\033[0m"
}
#################################
# Formats the output for options
# Globals:
#   None
# Arguments:
#   array help_texts
# Returns:
#   string
#################################
bashop::printer::help_formatter() {
  local help_texts=("${!1}")
  local help_text
  local help_regex="(.*)  (.*)"
  local help_text_first_parts=()
  for help_text in "${help_texts[@]}"; do
    if [[ ${help_text} =~ ${help_regex} ]]; then
      help_text_first_parts+=( "${BASH_REMATCH[1]}" )
    else
      bashop::printer::__framework_error "Wrong syntax for '${help_text}'. Must be 'WHAT  DESCRIPTION' (two spaces)"
      exit 1
    fi
  done
  local max_length=$(bashop::utils::max_string_length help_text_first_parts[@])
  for help_text in "${help_texts[@]}"; do
    if [[ ${help_text} =~ ${help_regex} ]]; then
      local length=${#BASH_REMATCH[1]}
      local no_spaces=$((max_length - length))
      spaces=$(bashop::utils::string_repeat ' ' ${no_spaces})
      bashop::printer::echo "  ${BASH_REMATCH[1]}${spaces}  " false
      bashop::printer::echo "${BASH_REMATCH[2]}"
    fi
  done
}
##########################################
# Checks the dependencies
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   None
##########################################
bashop::check_dependencies() {
  local req_version='4.0.0'
  if !(bashop::utils::check_version ${req_version} ${BASH_VERSION}); then
    local msg="Your version of bash is to low. Minimum required is '${req_version}', "
    msg+=", yours is '${BASH_VERSION}'"
    bashop::printer::error "${msg}"
    exit 1
  fi
}
bashop::start() {
  bashop::app::__start "${@}"
}
bashop::check_dependencies
##################################
# Shows the application help page
# Globals:
#   None
# Arguments:
#   string app_name
# Returns:
#   None
##################################
bashop::app::__show_help() {
  # Print app usage
  local app_name="${1}"
  bashop::printer::echo "Usage:"
  bashop::printer::echo "  ${app_name} <command> [options] <arguments>" "\n\n"
  bashop::printer::echo "Commands:"
  local commands=( ${0} )
  if [[ -d ${BASHOP_APP_COMMAND_ROOT} ]]; then
    commands=( ${BASHOP_APP_COMMAND_ROOT}/* )
  fi
  # Grep commands and show help page
  local commands_to_show=()
  local command
  for command in "${commands[@]}"; do
    local command_name=$([[ ${command} =~ ([^\/]+)$ ]] && echo "${BASH_REMATCH[1]}")
    local command_description=''
    while read line; do
      if [[ ${line} =~ ^#\?com([ ]*)(.*)$ ]]; then
        command_name=${BASH_REMATCH[2]}
      elif [[ ${line} =~ ^#\?d([ ]*)(.*)$ ]]; then
        command_description+="${BASH_REMATCH[2]}"
      elif [[ "${command_description}" != "" ]]; then
        commands_to_show+=( "${command_name//_/ }  ${command_description}" )
        command_description=''
      fi
    done < "${command}"
  done
  bashop::printer::help_formatter commands_to_show[@]
  bashop::printer::echo "" "\n"
  bashop::printer::echo "Options:"
  bashop::printer::help_formatter _BASHOP_BUILD_IN_OPTIONS[@]
}
#########################
# Starts the application
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   None
#########################
bashop::app::__start() {
  # Run app init function
  if (bashop::utils::function_exists "bashop::init"); then
    bashop::init
  fi
  # Get app name
  local app_name=$([[ ${0} =~ ([^\/]+)$ ]] && echo "${BASH_REMATCH[1]}")
  # Execute command
  local first_command=''
  if [[ -n ${1+1} ]]; then
    first_command="${1}"
  fi
  case "${first_command}" in
    "" | "-h" | "--help" )
      bashop::app::__show_help ${app_name}
      ;;
    * )
      # Check if we have a valid command
      local possible_command=()
      local command=()
      local command_path=''
      local command_name=''
      local tmp_path="${BASHOP_APP_COMMAND_ROOT}/"
      local param
      for param in ${@}; do
        if !(bashop::utils::is_option ${param}); then
          possible_command+=( ${param} )
          #command+=( ${param} )
        fi
      done
      local line
      local command_param
      if [[ -d ${BASHOP_APP_COMMAND_ROOT} ]]; then
        for command_param in "${possible_command[@]}"; do
          if [[ -f "${tmp_path}${command_param}" ]]; then
            tmp_path+=${command_param}
            command_path=${tmp_path}
            tmp_path+='_'
            command+=( ${command_param} )
          fi
        done
        if ! [[ -n ${command_path} ]]; then
          bashop::printer::error "The command '${possible_command[@]}' does not exists"
          exit 1
        fi
      else
        command_path=${0}
        while read line; do
          if [[ ${line} =~ ^#\?com([ ]*)(.*)$ ]]; then
            for command_param in "${possible_command[@]}"; do
              if [[ ${line} =~ ^#\?com([ ]*)${command_name}_?${command_param}([ ]*)$ ]]; then
                if [[ ${command_name} != "" ]]; then
                  command_name+="_"
                fi
                command+=( ${command_param} )
                command_name+=${command_param}
              fi
            done
          fi
        done < "${command_path}"
      fi
      # Grep options and arguments form the command file
      local command_arguments=()
      local command_options=()
      local inline_command_processed=false
      while read line; do
        if [[ ${line} =~ ^#\?com([ ]*)(${command_name})([ ]*)$ ]]; then
          command_arguments=()
          command_options=()
          inline_command_processed=true
        elif [[ ${line} =~ ^#\?com([ ]*)(.*)$ ]] && [[ ${inline_command_processed} == true ]]; then
          echo "end"
          break
        elif [[ ${line} =~ ^#\?c([ ]*)(.*)$ ]]; then
          command_arguments=( ${BASH_REMATCH[2]} )
        elif [[ ${line} =~ ^#\?o([ ]*)(.*)$ ]]; then
          command_options+=( "${BASH_REMATCH[2]}" )
        fi
      done < "${command_path}"
      local raw_arguments=("${@}")
      # Check if arguments given
      local no_command=${#command[@]}
      local no_args=${#raw_arguments[@]}
      local diff=$((no_args - no_command))
      # Set verbose mode
      if (bashop::utils::contains_element '-v' "${raw_arguments[@]}") ||
         (bashop::utils::contains_element '--verbose' "${raw_arguments[@]}")
      then
        _BASHOP_VERBOSE=true
        local raw_arg
        local raw_args_copy=( "${raw_arguments[@]}" )
        raw_arguments=()
        for raw_arg in "${raw_args_copy[@]}"; do
          if [[ ${raw_arg} != '-v' ]] && [[ ${raw_arg} != '--verbose' ]]; then
            raw_arguments+=( ${raw_arg} )
          fi
        done
      fi
      # If no arguments given and the command needs arguments show the help page
      if ( [[ ${#command_arguments[@]} -gt 0 ]] ) && [[ ${diff} -lt 1 ]] ||
         (bashop::utils::contains_element '-h' "${raw_arguments[@]}") ||
         (bashop::utils::contains_element '--help' "${raw_arguments[@]}")
      then
        local command_with_app_name=( "${app_name}" "${command[@]}" )
        bashop::command::__show_help command_with_app_name[@] command_arguments[@] command_options[@]
      else
        bashop::command::__parse_arguments command[@] command_arguments[@] command_options[@] raw_arguments[@]
        if (bashop::utils::function_exists "bashop::run_command"); then
          bashop::run_command
        elif (bashop::utils::function_exists "bashop::${command_name}::run_command"); then
          eval "bashop::${command_name}::run_command"
        else
          bashop::printer::__framework_error "Every command must define the function bashop::run_command"
        fi
      fi
      ;;
  esac
  # Run app destroy function
  if (bashop::utils::function_exists "bashop::destroy"); then
    bashop::destroy
  fi
}
##########################################
# Shows the command help page
# Globals:
#   array args
# Arguments:
#   array raw_command
#   array raw_command_arguments (optional)
#   array raw_command_options (optional)
# Returns:
#   None
##########################################
bashop::command::__show_help() {
  # Check which arguments given and not empty
  local raw_command=("${!1}")
  local raw_command_arguments=()
  if [[ -n ${!2+1} ]]; then
    raw_command_arguments=("${!2}")
  fi
  local raw_command_options=()
  if [[ -n ${!3+1} ]]; then
    raw_command_options=("${!3}")
  fi
  # Print command usage
  local full_command="${raw_command[@]}"
  bashop::printer::echo "Usage:"
  bashop::printer::echo "  ${full_command[@]} [options] " false
  if [[ ${#raw_command_arguments[@]} -gt 0 ]]; then
    local full_arguments="${raw_command_arguments[@]}"
    bashop::printer::echo "${full_arguments}" false
  fi
  bashop::printer::echo "" "\n\n"
  # Print command options
  bashop::printer::echo "Options:"
  if [[ ${#raw_command_options[@]} -gt 0 ]]; then
    raw_command_options=( "${raw_command_options[@]}" "${_BASHOP_BUILD_IN_OPTIONS[@]}" )
  else
    raw_command_options=( "${_BASHOP_BUILD_IN_OPTIONS[@]}" )
  fi
  bashop::printer::help_formatter raw_command_options[@]
}
##########################################
# Parses and validates the given argument
# Globals:
#   array args
# Arguments:
#   array raw_command
#   array raw_command_arguments
#   array raw_command_options
#   array raw_arguments
# Returns:
#   None
##########################################
bashop::command::__parse_arguments() {
  # Declare global argument array
  declare -g -A args=()
  # Get function arguments
  local raw_command=("${!1}")
  local raw_command_arguments=()
  if [[ -n ${!2+1} ]]; then
    local raw_command_arguments=("${!2}")
  fi
  local raw_command_options=()
  if [[ -n ${!3+1} ]]; then
    raw_command_options=("${!3}")
  fi
  local raw_arguments=("${!4}")
  # Regex for options
  local short_option_regex='(-[a-zA-Z]{1})([.]{3}){0,1}'
  short_option_regex+='( ([\<][a-z]+[\>])| ([A-Z]+)){0,1}'
  local long_option_regex='(--[a-zA-Z0-9][a-zA-Z0-9\-]+)([.]{3}){0,1}'
  long_option_regex+='(=([\<][a-z]+[\>])| ([A-Z]+)){0,1}'
  # ---- Command arguments ----
  local com_args_repeatable=false
  local com_args_required=()
  local com_args=()
  # Command regex
  local command_arg_regex='(([\<][a-zA-Z0-9_]+[\>])([.]{3}){0,1})'
  local command_arg_required_regex="^${command_arg_regex}$"
  local command_arg_optional_regex="^\[${command_arg_regex}\]$"
  # Get command arguments
  local command_argument
  if [[ ${#raw_command_arguments[@]} -gt 0 ]]; then
    for command_argument in "${raw_command_arguments[@]}"; do
      if [[ ${command_argument} =~ ${command_arg_required_regex} ]] || [[ ${command_argument} =~ ${command_arg_optional_regex} ]]; then
        local com_arg_name=${BASH_REMATCH[2]}
        local com_arg_rep=${BASH_REMATCH[3]}
        if [[ ${command_argument} =~ ${command_arg_required_regex} ]]; then
          com_args_required+=( ${com_arg_name} )
        fi
        com_args+=( ${com_arg_name} )
        if [[ ${com_args_repeatable} == false ]] && [[ -n "${com_arg_rep}" ]]; then
          com_args_repeatable=true
        elif [[ ${com_args_repeatable} == true ]]; then
          bashop::printer::__framework_error "Only the last argument can be repeatable, but you have defined '${raw_command_arguments[@]}'."
          exit 1
        fi
      elif [[ ${command_argument} =~ ${short_option_regex} ]] || [[ ${command_argument} =~ ${long_option_regex} ]]; then
        raw_command_options+=( ${command_argument} )
      fi
    done
  fi
  # ---- Command options ----
  # Get defined options
  declare -A opt_map=()
  declare -A opt_default_arg=()
  local opt_map opt_default_arg
  # Short option regex
  local option_regex+="^(${short_option_regex}[,]{0,1}[ ]{0,1}){0,1}"
  # Long option regex
  option_regex+="(${long_option_regex}){0,1}"
  # Check for default value
  option_regex+='([^\[]*)(\[default: ([a-zA-Z0-9]+)\]){0,1}.*$'
  local opt
  if [[ ${#raw_command_options[@]} -gt 0 ]]; then
    for opt in "${raw_command_options[@]}"; do
      # Check if option is valid
      if ! [[ ${opt} =~ ${option_regex} ]]; then
        bashop::printer::__framework_error "Wrong pattern for option '${opt}'."
        exit 1
      fi
      declare -A p_opts=()
      local p_opts
      # Get short options name and argument name
      p_opts["short_opt_name"]=${BASH_REMATCH[2]}
      p_opts["short_opt_repeatable"]=${BASH_REMATCH[3]}
      p_opts["short_opt_arg"]=''
      if [[ -n "${BASH_REMATCH[5]}" ]]; then
        p_opts["short_opt_arg"]=${BASH_REMATCH[5]}
      elif [[ -n "${BASH_REMATCH[6]}" ]]; then
        p_opts["short_opt_arg"]=${BASH_REMATCH[6]}
      fi
      # Get long options name and argument name
      p_opts["long_opt_name"]=${BASH_REMATCH[8]}
      p_opts["long_opt_repeatable"]=${BASH_REMATCH[9]}
      p_opts["long_opt_arg"]=''
      if [[ -n "${BASH_REMATCH[11]}" ]]; then
        p_opts["long_opt_arg"]=${BASH_REMATCH[11]}
      elif [[ -n "${BASH_REMATCH[12]}" ]]; then
        p_opts["long_opt_arg"]=${BASH_REMATCH[12]}
      fi
      # Get default option argument
      local default_option_arg=''
      if [[ -n "${BASH_REMATCH[15]}" ]]; then
        default_option_arg=${BASH_REMATCH[15]}
      fi
      local type_name=''
      local cur_opt=''
      # Set options
      if [[ -n "${p_opts["short_opt_name"]}" ]] && [[ -n "${p_opts["long_opt_name"]}" ]]; then
        # Repeatable
        if ( [[ -n "${p_opts["short_opt_repeatable"]}" ]] && ! [[ -n "${p_opts["long_opt_repeatable"]}" ]] ) ||
           ( ! [[ -n "${p_opts["short_opt_repeatable"]}" ]] && [[ -n "${p_opts["long_opt_repeatable"]}" ]] )
        then
          bashop::printer::__framework_error "One of the option of '${opt}' is repeatable so both must be repeatable."
          exit 1
        fi
        # Arguments
        if ( [[ -n "${p_opts["short_opt_arg"]}" ]] && ! [[ -n "${p_opts["long_opt_arg"]}" ]] ) ||
           ( ! [[ -n "${p_opts["short_opt_arg"]}" ]] && [[ -n "${p_opts["long_opt_arg"]}" ]] )
        then
          bashop::printer::__framework_error "One of the option of '${opt}' accepts an argument so both must accept one."
          exit 1
        fi
        opt_map["${p_opts["short_opt_name"]}"]=${p_opts["long_opt_name"]}
        type_name='long'
        cur_opt=${p_opts["long_opt_name"]}
      elif [[ -n "${p_opts["short_opt_name"]}" ]]; then
        type_name='short'
        cur_opt=${p_opts["short_opt_name"]}
      elif [[ -n "${p_opts["long_opt_name"]}" ]]; then
        type_name='long'
        cur_opt=${p_opts["long_opt_name"]}
      else
        bashop::printer::__framework_error "Wrong pattern for option '${opt}'."
        exit 1
      fi
      if [[ -n "${p_opts["${type_name}_opt_repeatable"]}" ]]; then
        args["${cur_opt},#"]=0
      else
        args[${cur_opt}]=''
      fi
      if [[ -n "${p_opts["${type_name}_opt_arg"]}" ]]; then
        if [[ -n "${default_option_arg}" ]]; then
          opt_default_arg[${cur_opt}]=${default_option_arg}
        else
          opt_default_arg[${cur_opt}]=''
        fi
      fi
    done
  fi
  # ---- Parse arguments ----
  local no_commands=${#raw_command[@]}
  local no_com_args=${#com_args[@]}
  local no_raw_arguments=${#raw_arguments[@]}
  local arg=''
  local current_arg=''
  local com_arg_counter=0
  local counter=0
  local req_param_name=''
  local double_dash=false
  # Iterate over the raw arguments
  while [[ ${counter} -lt ${no_raw_arguments} ]]; do
    arg=${raw_arguments[${counter}]}
    if [[ ${counter} -lt ${no_commands} ]] && !(bashop::utils::is_option ${arg}); then
      if [[ ${arg} != ${raw_command[${counter}]} ]]; then
        bashop::printer::__framework_error "Unknown command '${arg}' called"
        exit 1
      fi
    elif [[ ${arg} == '--' ]]; then
      double_dash=true
      args[${arg}]=''
    elif [[ ${double_dash} == true ]]; then
      args["--"]+=${arg}
      args["--"]+=' '
    elif (bashop::utils::is_option ${arg}); then
      local opt_argument=false
      if [[ ${arg} =~ (--[a-zA-Z0-9][a-zA-Z0-9\-]+)=(.*) ]]; then
        arg=${BASH_REMATCH[1]}
        opt_argument=${BASH_REMATCH[2]}
      fi
      # Check for valid option
      if (bashop::utils::key_exists ${arg} opt_map); then
        arg=${opt_map[${arg}]}
      elif !(bashop::utils::key_exists ${arg} args); then
        bashop::printer::error "Unkown option '${arg}'"
        exit 1
      fi
      local current_arg=${arg}
      # Check if arg is already set
      if !(bashop::utils::key_exists "${current_arg},#" args); then
        if [[ -n ${args["${current_arg}"]} ]]; then
          bashop::printer::error "'${current_arg}' can't be multiple defined"
          exit 1
        else
          args[${current_arg}]=true
        fi
      fi
      # Check if accept arguments and grep them
      if (bashop::utils::key_exists "${current_arg}" opt_default_arg); then
        local next=$((counter + 1))
        if [[ ${next} -lt ${no_raw_arguments} ]]; then
          arg=${raw_arguments[${next}]}
          if [[ -n "${arg}" ]] && !(bashop::utils::is_option ${arg}); then
            opt_argument=${arg}
            counter=${next}
          fi
        fi
        # Get argument
        if [[ ${opt_argument} == false ]] && [[ ${opt_default_arg["${current_arg}"]} != false ]]; then
          opt_argument=${opt_default_arg["${current_arg}"]}
        fi
        # Set default value if no is given or show error
        if [[ -n ${opt_argument} ]]; then
          if (bashop::utils::key_exists "${current_arg},#" args); then
            local no_opt_args=${args["${current_arg},#"]}
            args["${current_arg},${no_opt_args}"]="${opt_argument}"
            args["${current_arg},#"]=$((no_opt_args+1))
          else
            args[${current_arg}]="${opt_argument}"
          fi
        else
          bashop::printer::error "Missing required argument for option '${current_arg}'"
          exit 1
        fi
      fi
    elif [[ ${com_arg_counter} -lt ${no_com_args} ]] || [[ ${com_args_repeatable} == true ]]; then
      local req_param_name=${com_args[${com_arg_counter}]}
      if [[ ${com_arg_counter} -eq $((no_com_args - 1)) ]] && [[ ${com_args_repeatable} == true ]]; then
        local no_opt_args=0
        if (bashop::utils::key_exists "${req_param_name},#" args); then
          no_opt_args=${args["${req_param_name},#"]}
        fi
        args["${req_param_name},${no_opt_args}"]="${arg}"
        args["${req_param_name},#"]=$((no_opt_args+1))
      else
        args[${req_param_name}]=${arg}
        com_arg_counter=$((com_arg_counter + 1))
      fi
    else
      bashop::printer::error "Unknown argument '${arg}'"
      exit 1
    fi
    counter=$((counter + 1))
  done
  # Check if all required args are set
  local com_arg_req
  if [[ ${#com_args_required[@]} -gt 0 ]]; then
    for com_arg_req in "${com_args_required[@]}"; do
      if !(bashop::utils::key_exists ${com_arg_req} args); then
        bashop::printer::error "Missing required command argument '${com_arg_req}'"
        exit 1
      fi
    done
  fi
  # Everything done now set the args to read only
  readonly args
}
bashop::start "${@}"
